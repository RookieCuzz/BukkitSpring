# Spigot 插件内置简易版 Spring：IoC + DI 设计总结（Java 17/21）

> 目标：在 Spigot/Paper 插件中实现一个 **轻量、可控、启动快** 的 IoC/DI 容器，风格更像 Spring（注解驱动、按类型装配、生命周期回调），但只做“够用”的一套。

外部插件引入当前的IOC/DI框架插件,然后使用xxxx.registerPlugin(this)注册,IOC/DI框架插件会扫描当前插件的类并生成一个专属的容器,在容器内对当前插件的插件依赖进行注入.

---

## 0. 关键约束（Spigot/Paper 环境）

- 容器生命周期建议绑定到 `JavaPlugin` 的 `onLoad/onEnable/onDisable`：  
  `onLoad` 在插件加载后、启用前调用；多插件时 **所有 onLoad 都会先执行，再执行任何 onEnable**。:contentReference[oaicite:0]{index=0}
- 每个插件有自己的类加载器（`PluginClassLoader` / Paper API 同名类），扫描/反射时应使用 **插件自己的 ClassLoader**。:contentReference[oaicite:1]{index=1}

---

## 1. MVP 范围（先做这些就能落地）

### 1.1 Bean 注册
- 注解扫描注册：
  - `@Component`（统一入口）
  - `@Configuration` + `@Bean`（可选，后期增强）
- 手动注册（补充能力）：
  - `bindInstance(type, instance)`
  - `bindProvider(type, provider)`

### 1.2 注入方式
- 构造器注入：默认首选（依赖显式、易测试）
- 字段/Setter 注入：可选（用于少样板或配合循环依赖策略）

### 1.3 Scope
- `singleton`（默认）
- `prototype`（可选，很多插件不需要）

### 1.4 生命周期
- `@PostConstruct`：注入完成后回调
- `@PreDestroy`：插件 disable 时回调（关闭线程池/DB 连接等）

> 注意：Java 11+ 之后 `javax.annotation` 不再内置；Jakarta EE 9 起迁移到 `jakarta.annotation`，需要显式引入 `jakarta.annotation-api`。:contentReference[oaicite:2]{index=2}

---

## 2. 依赖建议（Gradle/Maven）

### 2.1 类扫描（推荐 ClassGraph）
ClassGraph 对 jar/classpath 扫描很成熟，且支持指定 classloader。:contentReference[oaicite:3]{index=3}

### 2.2 生命周期注解
使用 `jakarta.annotation-api` 来获得 `@PostConstruct/@PreDestroy`。:contentReference[oaicite:4]{index=4}

---

## 3. 容器核心结构（建议的数据结构）

### 3.1 BeanDefinition
记录：
- `Class<?> type`
- `String name`（默认：simpleName 首字母小写；或来自 `@Component("xxx")`）
- `Scope scope`（SINGLETON / PROTOTYPE）
- 构造器元信息（选哪个构造器、参数列表）
- 注入点列表（字段/方法）
- 生命周期回调（postConstruct/preDestroy 方法引用）

### 3.2 运行期缓存
- `Map<Key, Object> singletons`：完整单例
- `Map<Key, Object> earlySingletons`：早期引用（可选，用于字段/Setter 循环依赖）
- `Set<Key> creating`：创建中的 bean，用于循环检测/报错

其中 `Key` 可由 `(type + qualifierName?)` 组成。

---

## 4. 注解设计（更像 Spring，但精简）

### 4.1 组件与配置
- `@Component(value="")`
- `@Configuration`（可选）
- `@Bean(name="")`（可选）

### 4.2 自动装配
- `@Autowired(required=true)`（构造器/字段/方法）
- `@Qualifier("name")`（解决多实现冲突）
- `@Primary`（默认优先）
- `@Lazy`（可选：注入 Provider 或延迟代理）

### 4.3 生命周期（推荐直接复用 Jakarta）
- `jakarta.annotation.PostConstruct`
- `jakarta.annotation.PreDestroy` :contentReference[oaicite:5]{index=5}

---

## 5. 类扫描策略（非常关键）

### 5.1 扫描包白名单
只扫你插件自己的根包，例如：`com.yourname.yourplugin`

### 5.2 使用插件 classloader
扫描时将 classloader 设为 `plugin.getClass().getClassLoader()`，避免扫描到别的插件或服务器端类。  
（Paper/Spigot 下插件类加载器就是 `PluginClassLoader` 的体系）:contentReference[oaicite:6]{index=6}

### 5.3 建议实现
- `scanComponents(basePackage)`
- 找到 `@Component/@Configuration` 类，生成 BeanDefinition
- （可选）解析 `@Configuration` 内 `@Bean` 方法，注册为工厂 BeanDefinition

---

## 6. Bean 创建流程（推荐实现顺序）

### 6.1 选择构造器
规则（简单可控）：
1. 有且仅有一个构造器：用它
2. 有 `@Autowired` 标注的构造器：用它
3. 否则选“参数最多”的 public 构造器（可选策略）

### 6.2 解析依赖
对每个参数：
- 如果存在 `@Qualifier`：按 name 精确找
- 否则按类型找：
  - 只有一个候选：注入
  - 多个候选：
    - 有 `@Primary`：选 primary
    - 否则报错（提示使用 @Qualifier 或 @Primary）

### 6.3 两阶段初始化（可选，用于字段/Setter 与循环依赖）
- Phase 1：仅构造器实例化
- Phase 2：字段/Setter 注入 + `@PostConstruct`
- 完成后进入 `singletons`

---

## 7. 循环依赖策略（务实版本）

### 7.1 默认：禁止构造器循环依赖
- A 构造器需要 B，B 构造器需要 A：直接报错（提示重构/改为 Provider/@Lazy）
- 这会让设计更健康，也避免把容器复杂度做成“半个 Spring”。

### 7.2 可选增强：支持字段/Setter 循环依赖（早期引用）
实现方式（简化版）：
1. 构造 A → 放入 `earlySingletons`
2. 创建 B 时需要 A → 先从 `earlySingletons` 取到 A
3. B 完成 → 放入 `singletons`
4. 回到 A 继续注入 B → A 完成 → 放入 `singletons`

> 如果你未来不做 AOP/代理，这个“早期引用两级缓存”通常就够了；Spring 的三级缓存更多是为了解决“早期代理”等复杂情况（你可以先不做）。  

### 7.3 最推荐：Provider / Lazy
- 注入 `Provider<T>` 或 `Supplier<T>`：
  - 用到时再 `get()`，天然打破环
- `@Lazy` 可以语义化地生成 Provider（或动态代理，后期再做）

---

## 8. 与 Spigot 插件整合（建议的接入点）

### 8.1 插件主类生命周期
- `onLoad()`：可扫描 classpath、构建 BeanDefinition（轻量）
- `onEnable()`：创建容器、完成单例初始化、注册 Listener/Command
- `onDisable()`：容器 close，执行 `@PreDestroy`

`onLoad/onEnable/onDisable` 的调用时机见 Bukkit/Spigot API 文档。:contentReference[oaicite:7]{index=7}

### 8.2 内建绑定（强烈建议）
在容器启动时直接提供：
- `JavaPlugin` / `Plugin`
- `Logger`
- `Server`
- `PluginManager`
- `FileConfiguration`
- `Scheduler`（你封装一层更好，比如 `TaskExecutor`）

---

## 9. 对外 API（建议长这样）

### 9.1 Container / ApplicationContext
- `T get(Class<T> type)`
- `T get(Class<T> type, String qualifier)`
- `void bindInstance(Class<T> type, T instance)`
- `void bindProvider(Class<T> type, Provider<T> provider)`
- `void scan(String... basePackages)`
- `void refresh()`（初始化单例、执行 PostConstruct）
- `void close()`（执行 PreDestroy）

### 9.2 Provider
- `interface Provider<T> { T get(); }`

---

## 10. 错误与诊断（务必做，不然很难用）

- “找不到 bean”：输出需要的 type/qualifier、已注册的候选列表
- “多候选冲突”：输出候选来源与建议（@Primary/@Qualifier）
- “循环依赖”：输出依赖链 A -> B -> C -> A
- “生命周期异常”：标注具体 bean/method 并附异常栈

---

## 11. 分阶段实现路线（建议）

1) 手动 bind + 构造器注入 + get()  
2) ClassGraph 扫描 @Component（指定插件 classloader + base package）:contentReference[oaicite:8]{index=8}  
3) 字段/Setter 注入（可选）  
4) PostConstruct/PreDestroy（使用 jakarta.annotation-api）:contentReference[oaicite:9]{index=9}  
5) 冲突处理（Qualifier/Primary）  
6) Provider/@Lazy（强烈建议）  
7) 可选：字段/Setter 循环依赖 earlySingletons  

---

## 12. 你这个场景的“最佳实践建议”

- 插件项目里优先用 **构造器注入 + Provider**，少用字段注入
- 循环依赖尽量靠 **设计解耦**解决，不要完全依赖容器“魔法”
- 扫描范围越小越好（只扫你的根包）
- 容器启动失败要尽早暴露（onEnable 阶段就 refresh 并 fail-fast）

---
